//! Core CCD types.

use bitcoin::secp256k1::{PublicKey, Scalar};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use zeroize::{Zeroize, ZeroizeOnDrop};

/// A 32-byte chain code, withheld from the co-signer.
#[derive(Clone, Zeroize, ZeroizeOnDrop)]
pub struct ChainCode(pub [u8; 32]);

impl ChainCode {
    pub fn from_bytes(bytes: [u8; 32]) -> Self {
        Self(bytes)
    }
}

/// A co-signer's registration: bare public key + owner-generated chain code.
/// The co-signer never sees `chain_code`.
#[derive(Clone)]
pub struct DelegatedKey {
    /// Co-signer's bare public key (they generated this keypair themselves)
    pub cosigner_pubkey: PublicKey,
    /// Chain code generated by the owner FOR this co-signer's key tree.
    /// NEVER shared with the co-signer.
    pub chain_code: ChainCode,
    /// Human-readable label (e.g., "heir-alice", "signer-office")
    pub label: String,
}

/// A tweak disclosure â€” sent to the co-signer at signing time.
/// This is the ONLY information the co-signer receives about the key tree.
#[derive(Clone, Debug)]
pub struct TweakDisclosure {
    /// The scalar tweak: co-signer adds this to their secret key
    pub tweak: Scalar,
    /// The resulting derived public key (for verification)
    pub derived_pubkey: PublicKey,
    /// Which child index this tweak derives
    pub child_index: u32,
}

/// Serializable tweak request for Nostr transport.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TweakRequest {
    /// Protocol version
    pub version: u8,
    /// Message type
    #[serde(rename = "type")]
    pub msg_type: String,
    /// Hex-encoded scalar tweak
    pub tweak: String,
    /// Hex-encoded derived public key
    pub derived_pubkey: String,
    /// Child index
    pub child_index: u32,
    /// Optional: outpoint this tweak is for (txid:vout)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outpoint: Option<String>,
}

/// Serializable tweak acknowledgment.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TweakAck {
    pub version: u8,
    #[serde(rename = "type")]
    pub msg_type: String,
    /// Hex-encoded derived public key (confirms receipt)
    pub derived_pubkey: String,
    /// Whether the co-signer accepted the tweak
    pub accepted: bool,
}

/// A CCD vault: Taproot output from owner + delegated co-signer.
#[derive(Clone)]
pub struct CcdVault {
    /// The owner's public key for this vault
    pub owner_pubkey: PublicKey,
    /// The delegated co-signer registration
    pub delegated: DelegatedKey,
    /// Derivation index for this vault's address (non-hardened)
    pub address_index: u32,
    /// The co-signer's derived public key at this index
    pub cosigner_derived_pubkey: PublicKey,
    /// The aggregated x-only public key (internal key for key-path spend)
    pub aggregate_xonly: bitcoin::key::XOnlyPublicKey,
    /// The Taproot address
    pub address: bitcoin::Address,
    /// Network
    pub network: bitcoin::Network,
}

/// A tweak for a single PSBT input.
#[derive(Clone)]
pub struct InputTweak {
    /// Which PSBT input index
    pub input_index: usize,
    /// The scalar tweak
    pub tweak: Scalar,
    /// Expected derived pubkey (for verification)
    pub derived_pubkey: PublicKey,
}

/// Serializable signing request for Nostr transport.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SigningSessionMessage {
    pub version: u8,
    #[serde(rename = "type")]
    pub msg_type: String,
    /// Base64-encoded PSBT
    pub psbt: String,
    /// Tweaks for each input
    pub input_tweaks: Vec<SerializedInputTweak>,
}

/// Serialized input tweak for transport.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SerializedInputTweak {
    pub input_index: usize,
    /// Hex-encoded scalar tweak
    pub tweak: String,
    /// Hex-encoded derived pubkey
    pub derived_pubkey: String,
}

/// Co-signer's signing response for Nostr transport.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SigningResponseMessage {
    pub version: u8,
    #[serde(rename = "type")]
    pub msg_type: String,
    /// Hex-encoded Schnorr signatures, one per input
    pub partial_sigs: Vec<SerializedPartialSig>,
    pub accepted: bool,
}

/// A single partial signature for transport.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SerializedPartialSig {
    pub input_index: usize,
    /// Hex-encoded 64-byte Schnorr signature
    pub signature: String,
}

#[derive(Error, Debug)]
pub enum CcdError {
    #[error("Hardened derivation indices not supported in CCD")]
    HardenedIndex,
    #[error("Tweak scalar out of curve order range")]
    TweakOutOfRange,
    #[error("Derivation failed: {0}")]
    DerivationFailed(String),
    #[error("Invalid path: {0}")]
    InvalidPath(String),
    #[error("Transport error: {0}")]
    TransportError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
    #[error("PSBT error: {0}")]
    PsbtError(String),
    #[error("Signing error: {0}")]
    SigningError(String),
    #[error("Tweak verification failed for input {0}")]
    TweakVerificationFailed(usize),
    #[error("Invalid signature: {0}")]
    InvalidSignature(String),
}
